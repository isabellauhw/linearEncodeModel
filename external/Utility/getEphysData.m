function data = getEphysData(ephysDir, varargin)
%   data = getEphysData(ksDir)
%   Loads kilosorted and phy-curated electrophysiology data. The function 
%   returns 'data' which contains tables:
%   -'spike' table contains data associated with each single spike event.
%   -'cluster' table contains data associated with each cluster
%   -'channel' table contains data associated with each channel
%   
%   If the ephys-alignment-gui has been run and the channel_locations.json
%   file is present in the ephys directory, then the brain regiongpu
%   information is included in the cluster table.
%
%   getEphysKSData(...,Name,Value) specifies options using one or more
%   Name,Value pair arguments.
%
%     'includeNoise'   - true/false (default false) for whether the output
%     data includes clusters labelled as noise in phy.

p = inputParser;
addRequired(p,'ksDir',@(x) exist(x,'dir'));
addParameter(p,'includeNoise',false,@islogical);
parse(p,ephysDir,varargin{:})

ephysDir = p.Results.ksDir;
includeNoise = p.Results.includeNoise;

%% Spike table: build table of spike information. Each row corresponds to a single spike events.

%Load time of each spike event
spike = table;
meta = loadParamsPy(fullfile(ephysDir, 'params.py'));
ss = readNPY(fullfile(ephysDir, 'spike_times.npy'));
spike.time = double(ss)/meta.sample_rate;

%Load cluster ID associated with each spike event
spike.cluID = readNPY(fullfile(ephysDir, 'spike_clusters.npy'));

%Load template scaling amplitude associated with each spike event
spike.templateScalingAmplitude = readNPY(fullfile(ephysDir, 'amplitudes.npy'));


%% Channel table: build table of channel information. Each row is one channel.
channel = table;
channelMap = readNPY(fullfile(ephysDir, 'channel_map.npy')); if isrow(channelMap); channelMap = channelMap'; end;
channel.chanID = channelMap;
coords = readNPY(fullfile(ephysDir, 'channel_positions.npy'));
channel.localXPos = coords(:,1); %X position of channel relative to probe tip
channel.localYPos = coords(:,2); %Y position of channel relative to probe tip

%if available, load the output of the ephys alignment GUI and add
%information about brain area for each channel
ephysAlignmentOutputFile = fullfile(ephysDir, 'Histology_Alignment', 'channel_locations.json');
if exist(ephysAlignmentOutputFile, 'file')
    channel.hemisphere = cell(size(channel.chanID));
    out = jsondecode(fileread(ephysAlignmentOutputFile));
    
    % Loop through each channel, and add the corresponding data to the
    % table
    for i = 1:height(channel)
        channel.brainRegionID(i) = out.(['channel_' num2str(i-1)]).brain_region_id;
        channel.brainRegion(i) = {out.(['channel_' num2str(i-1)]).brain_region};
        channel.ML_mm(i) = out.(['channel_' num2str(i-1)]).x/1000 ;
        channel.AP_mm(i) = out.(['channel_' num2str(i-1)]).y/1000 ;
        channel.DV_mm(i) = out.(['channel_' num2str(i-1)]).z/1000 ;
        
        %add hemisphere information
        if out.(['channel_' num2str(i-1)]).x > 0
            channel.hemisphere{i} = 'Right';
        else
            channel.hemisphere{i} = 'Left';
        end
    end
   
end

%% Cluster table: build table of cluster information. Each row is one cluster.

%cluster_info.tsv generated by phy
hasClusterInfo = exist(fullfile(ephysDir,'cluster_info.tsv'), 'file')==2;
if hasClusterInfo %run through phy
    
    %Load cluster info table
    cluster = struct2table(tdfread( fullfile(ephysDir,'cluster_info.tsv') ));
    
    %rename columns to be more meaningful/uniform
    colNames = cluster.Properties.VariableNames;
    colNames{ismember(colNames,{'id','cluster_id'})} = 'cluID';
    colNames{strcmp(colNames,'ch')} = 'chanID';
    colNames{strcmp(colNames,'fr')} = 'avgFiringRate';
    colNames{strcmp(colNames,'n_spikes')} = 'numSpikes';
    colNames{strcmp(colNames,'sh')} = 'shankID';
    colNames{strcmp(colNames,'group')} = 'phyLabel';
    colNames{strcmp(colNames,'Amplitude')} = 'amplitude';
    colNames{strcmp(colNames,'ContamPct')} = 'contamPercent';
    colNames{strcmp(colNames,'KSLabel')} = 'ksLabel';
    cluster.Properties.VariableNames = colNames;
    cluster.phyLabel = categorical(cellstr(cluster.phyLabel));
    cluster.ksLabel = categorical(cellstr(cluster.ksLabel));
 
else %not run through phy
    warning('No phy curation detected. Loading raw kilosort output');
    amps = struct2table( tdfread( fullfile(ephysDir,'cluster_Amplitude.tsv')));
    kslabel = struct2table( tdfread( fullfile(ephysDir,'cluster_KSLabel.tsv')));
    cluster = innerjoin(amps,kslabel,'keys','cluster_id');
    colNames = cluster.Properties.VariableNames;
    colNames{strcmp(colNames,'cluster_id')} = 'cluID';
    colNames{strcmp(colNames,'KSLabel')} = 'ksLabel';
    colNames{strcmp(colNames,'Amplitude')} = 'amplitude';
    cluster.Properties.VariableNames = colNames;
    cluster.ksLabel = categorical(cellstr(cluster.ksLabel));
end

%add KS template
temps = readNPY(fullfile(ephysDir, 'templates.npy'));
cluster.kilosortTemplate(1:size(temps,1),:,:) = temps;

%Add brain region label to each cluster if present in tbe channel table
if ismember('brainRegion', channel.Properties.VariableNames)
    cluster = innerjoin(cluster, channel, 'keys', {'chanID'});
    cluster = sortrows(cluster,'cluID');
end

%Exclude noise clusters unless disabled
if ~includeNoise & hasClusterInfo
    badCluIDs = cluster.cluID(cluster.phyLabel=='noise');
    
    spike(ismember(spike.cluID, badCluIDs),:) = [];
    cluster(ismember(cluster.cluID, badCluIDs), :) = [];
end

%Compile tables into output format
data = struct('spike',spike, 'cluster', cluster, 'channel', channel, 'meta', meta);

end